diff --git a/TIS.py b/TIS.py
index a090364..0cb46ae 100644
--- a/TIS.py
+++ b/TIS.py
@@ -1,5 +1,6 @@
 import gi
 import logging
+import pdb
 
 gi.require_version("Gst", "1.0")
 gi.require_version("Tcam", "0.1")
@@ -72,12 +73,12 @@ class TIS:
                       ! ximagesink name=xsink"
         elif video_path is not None:
             p = "tcambin name=source"
+            p += " ! identity name=id"
             p += " ! capsfilter name=bayercaps"
             p += " ! bayer2rgb ! videoconvert"
             p += " ! capsfilter name=rawcaps"
             p += " ! videoconvert" 
             p += " ! avimux"
-            p += " ! identity name=id"
             p += " ! filesink name=fsink"
 
         logging.debug(f"Gst pipeline: {p}")
@@ -99,7 +100,7 @@ class TIS:
 
             try:
                 self.identity = self.pipeline.get_by_name("id")
-                self.identity.connect("handoff", self.queue.add_frame)
+                self.identity.connect("handoff", self.on_new_buffer)
             except AttributeError:
                 logging.warning("No identity detected")
 
@@ -121,18 +122,25 @@ class TIS:
         self.pipeline.set_state(Gst.State.READY)
         self.pipeline.set_state(Gst.State.NULL)
 
-    # def Set_Image_Callback(self, function, *data):
-    #     """ Sets the specific function called when a frame is received """
-    #     self.ImageCallback = function
-    #     self.ImageCallbackData = data
-
-    # def on_new_buffer(self, identity, buff ):
-    #     """ Set the generic ffunction called when a frame is received """
-    #     if self.buffer_lock:
-    #         logging.error("[!] Buffer is locked!")
-    #         return False
-    #     self.ImageCallback(self, *self.ImageCallbackData);
-    #     return False
+    def Set_Image_Callback(self, function, *data):
+        """ Sets the specific function called when a frame is received """
+        self.ImageCallback = function
+        self.ImageCallbackData = data
+
+    def on_new_buffer(self, identity, buff):
+        """ Set the generic ffunction called when a frame is received """
+        if self.buffer_lock:
+            logging.error("[!] Buffer is locked!")
+            return False
+        # func = buff.foreach_meta(lambda x: True)
+        # print(func)
+        # mem = buff.get_all_memory()
+        # success, info = mem.map(Gst.MapFlags.READ)
+
+        # meta = buff.get_meta("TcamStatisticsMetaApi")
+        # pdb.set_trace()
+        self.ImageCallback(self, identity, buff, *self.ImageCallbackData);
+        return False
 
     def getcaps(self, bayer=False):
         """ Get pixel and sink format and frame rate """
diff --git a/camera.py b/camera.py
index 8bb0116..4edf9f1 100644
--- a/camera.py
+++ b/camera.py
@@ -84,25 +84,25 @@ class Camera(TIS.TIS):
         self.queue = Queue(self.path_to_output,
                            self.config.pwm['chunk_pause'],
                            self.config.pwm['chunk_size'])
-        # self.Set_Image_Callback(add_frame, self.queue)
+        self.Set_Image_Callback(add_frame, self.queue)
 
     def apply_properties(self):
         "Apply properties to camera."
         for k, v in self.config.properties.items():
             self.setProperty(k, v)
 
-# def add_frame(tisobject, queue):
-#     "Write a timestamp and increases the counter."
-#     if queue.busy:
-#         logging.error("[!] Frame dropped!")
-#         return
-#     queue.busy = True
-#     t = time.time()
-#     queue.timestamps[queue.counter] = t
-#     queue.time_of_last_frame = t
-#     queue.counter += 1
-#     logging.info(f"Adding frame {queue.counter} to the queue")
-#     queue.busy = False
+def add_frame(tis, identity, buff, queue):
+    "Write a timestamp and increases the counter."
+    if queue.busy:
+        logging.error("[!] Frame dropped!")
+        return
+    queue.busy = True
+    t = time.time()
+    queue.timestamps[queue.counter] = t
+    queue.time_of_last_frame = t
+    queue.counter += 1
+    logging.info(f"Adding frame {queue.counter} to the queue")
+    queue.busy = False
 
 class Queue:
     """An object to manage video naming and checks the delay between triggers.
@@ -147,19 +147,6 @@ class Queue:
             else:
                 pass
 
-    def add_frame(self, *args):
-        "Write a timestamp and increases the counter."
-        if self.busy:
-            logging.error("[!] Frame dropped!")
-            return
-        self.busy = True
-        t = time.time()
-        self.timestamps[self.counter] = t
-        self.time_of_last_frame = t
-        self.counter += 1
-        logging.info(f"Adding frame {self.counter} to the self")
-        self.busy = False
-
     def log_frame_number_warning(self):
         "Log a warning with the actual and expected frame numbers."
         frames_chunk = self.counter - self.relative_zero
